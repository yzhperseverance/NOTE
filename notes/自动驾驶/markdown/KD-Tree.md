# KD-Tree

​	对K维空间的点进行存储的数据结构，通过KD树可以快速查询。

​	假如有点：
```
点1: (2, 3)
点2: (5, 4)
点3: (9, 6)
点4: (10, 2)
点5: (15, 8)
```

首先需要构建KD树，先将所有点按第一维也就是x轴坐标由小到大排序，结果为：

```
(2,3),(5,4),(9,6),(10,2),(15,8)
```

然后将中位数（9, 6）作为根节点，左边两个作为根的左子树，右边两个作为根的右子树。接着按第二维也就是y轴坐标排序，结果为：

```
左子树：(2,3),(5,4)
右子树：(10,2),(15,8)
```

在偶数个点的情况下，选大的那个座位根节点，因此左子树根为(5, 4)，右子树根为(15, 8)，最终的KD树结构为：

```
        (9, 6)  <-- 根节点
       /      \
   (5, 4)    (10, 2)
   /            \
(2, 3)       (15, 8)
```



现在假设需要查询的点为(7, 2)。

1. 计算当前节点和根节点的距离$d=\sqrt{20}$，定义超球半径为$\sqrt{20}$，超球半径就是当前的最短距离，距离大于超球半径的点不需要考虑。
2. 由于7小于9，所以先向左子树搜索，目标点与左子树根节点的距离$d=2\sqrt{2}$，更新超球半径为$2\sqrt{2}$
3. 由于目标点的y坐标2小于4，因此继续往左子树搜索，发现距离大于当前超球半径，并且已经到了叶节点，返回到父节点并判断是否需要搜索右子树，由于（5, 4）没有右子树，因此继续返回到根节点。
4. 判断是否需要搜索根节点的右子树，由于根节点的右子树都是x比它大的，但y不一定，所以先计算目标点与根节点在x轴方向上的距离，距离为2<d，因此右子树中有可能存在一个点距离比d小。假设2>d，那么光x轴方向上的距离就已经大于d了，y轴的距离不管是多少都不小于这个距离，因此就不用搜索右子树了。
5. 继续搜索右子树，在（10, 2）处更新d，然后由于2=2，所以开始先搜索左子树，左子树是空的再搜索右子树

**注意：子节点与目标点的距离不一定大于父节点与目标点的距离，否则根节点就应该是离得最近的了，KD树的节点之间关系并不是距离远近关系，只是把他们按中位数分隔开了。**

==**什么时候可以剪枝？**==

​	对于目标点(7, 2)，首先按构建KD树的规则先对根节点的左子树搜索，在第二层中再根据y的坐标再按左子树搜索，当搜索完之后，再来判断每层需不需要搜索另一子树。对于第二层，(5, 4)的右子树的y值是大于4的，并且目标点的y值是小于4的，所以只需要计算目标点和(5, 4)y值的差，如果大于当前距离最小值，就没必要搜索另一子树了。所以剪枝本质上就是已知现在目标点所在区间，那么他是否需要搜索另一区间只需要判断某一维度跟区间的隔断点的距离是否大于当前找到的距离最小值即可。





